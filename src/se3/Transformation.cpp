//////////////////////////////////////////////////////////////////////////////////////////////
/// \file Transformation.cpp
/// \brief Implementation file for a transformation matrix class.
/// \details Light weight transformation class, intended to be fast, and not to provide
///          unnecessary functionality.
///
/// \author Sean Anderson
//////////////////////////////////////////////////////////////////////////////////////////////

#include <lgmath/se3/Transformation.hpp>

#include <lgmath/se3/Operations.hpp>

#include <glog/logging.h>

namespace lgmath {
namespace se3 {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Default constructor
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation::Transformation() :
  C_ba_(Eigen::Matrix3d::Identity()), r_ab_inb_(Eigen::Vector3d::Zero()) {
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Copy constructor
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation::Transformation(const Transformation& T) :
  C_ba_(T.C_ba_), r_ab_inb_(T.r_ab_inb_) {
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Constructor
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation::Transformation(const Eigen::Matrix4d& T) :
  C_ba_(T.block<3,3>(0,0)), r_ab_inb_(T.block<3,1>(0,3)) {
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Constructor. The transformation will be T_ba = [C_ba, -C_ba*r_ba_ina; 0 0 0 1]
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation::Transformation(const Eigen::Matrix3d& C_ba, const Eigen::Vector3d& r_ba_ina) :
  C_ba_(C_ba), r_ab_inb_(-C_ba*r_ba_ina) {
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Constructor. The transformation will be T_ba = vec2tran(xi_ab)
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation::Transformation(const Eigen::Matrix<double,6,1>& xi_ab, unsigned int numTerms) {
  lgmath::se3::vec2tran(xi_ab, &C_ba_, &r_ab_inb_, numTerms);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Constructor. The transformation will be T_ba = vec2tran(xi_ab), xi_ab must be 6x1
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation::Transformation(const Eigen::VectorXd& xi_ab) {

  // Logic error
  CHECK(xi_ab.rows() == 6);

  // Construct using exponential map
  lgmath::se3::vec2tran(xi_ab, &C_ba_, &r_ab_inb_, 0);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Assignment operator. Note pass-by-value is intentional.
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation& Transformation::operator=(Transformation T) {
  // Swap (this)'s parameters with the temporary object passed by value
  // The temporary object is then destroyed at end of scope
  std::swap( this->C_ba_, T.C_ba_ );
  std::swap( this->r_ab_inb_, T.r_ab_inb_ );
  return (*this);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Gets basic matrix representation of the transformation
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix4d Transformation::matrix() const {
  Eigen::Matrix4d T_ba = Eigen::Matrix4d::Identity();
  T_ba.topLeftCorner<3,3>() = C_ba_;
  T_ba.topRightCorner<3,1>() = r_ab_inb_;
  return T_ba;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Gets the underlying rotation matrix
//////////////////////////////////////////////////////////////////////////////////////////////
const Eigen::Matrix3d& Transformation::C_ba() const {
  return C_ba_;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Gets the "forward" translation r_ba_ina = -C_ba.transpose()*r_ab_inb
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Vector3d Transformation::r_ba_ina() const {
  return -C_ba_.transpose()*r_ab_inb_;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Gets the underlying r_ab_inb vector.
//////////////////////////////////////////////////////////////////////////////////////////////
const Eigen::Vector3d& Transformation::r_ab_inb() const {
  return r_ab_inb_;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Get the corresponding Lie algebra using the logarithmic map
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,6,1> Transformation::vec() const {
  return lgmath::se3::tran2vec(this->C_ba_, this->r_ab_inb_);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Get the inverse matrix
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation Transformation::inverse() const {
  Transformation temp;
  temp.C_ba_ = C_ba_.transpose();
  temp.r_ab_inb_ = -C_ba_.transpose()*r_ab_inb_;
  return temp;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Get the 6x6 adjoint transformation matrix
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,6,6> Transformation::adjoint() const {
  return lgmath::se3::tranAd(C_ba_, r_ab_inb_);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief In-place right-hand side multiply T_rhs
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation& Transformation::operator*=(const Transformation& T_rhs) {
  r_ab_inb_ = C_ba_*T_rhs.r_ab_inb_ + r_ab_inb_;
  C_ba_ = C_ba_*T_rhs.C_ba_;
  return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Right-hand side multiply T_rhs
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation Transformation::operator*(const Transformation& T_rhs) const {
  Transformation temp(*this);
  temp *= T_rhs;
  return temp;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief In-place right-hand side multiply this matrix by the inverse of T_rhs
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation& Transformation::operator/=(const Transformation& T_rhs) {
  this->r_ab_inb_ = this->C_ba_ * -T_rhs.C_ba_.transpose()*T_rhs.r_ab_inb_ + this->r_ab_inb_;
  this->C_ba_ = this->C_ba_*T_rhs.C_ba_.transpose();
  return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Right-hand side multiply this matrix by the inverse of T_rhs
//////////////////////////////////////////////////////////////////////////////////////////////
Transformation Transformation::operator/(const Transformation& T_rhs) const {
  Transformation temp(*this);
  temp /= T_rhs;
  return temp;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Right-hand side multiply this matrix by the homogeneous vector p_a
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Vector4d Transformation::operator*(const Eigen::Vector4d& p_a) const {
  Eigen::Vector4d p_b;
  p_b.head<3>() = C_ba_*p_a.head<3>() + r_ab_inb_*p_a[3];
  p_b[3] = p_a[3];
  return p_b;
}

} // se3
} // lgmath

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief print transformation
//////////////////////////////////////////////////////////////////////////////////////////////
std::ostream& operator<<(std::ostream& out, const lgmath::se3::Transformation& T) {
  out << std::endl << T.matrix() << std::endl;
  return out;
}


