//
// Created by kai on 11/08/15.
//

#ifndef LGMATH_PRECISIONTIMER_HPP
#define LGMATH_PRECISIONTIMER_HPP

#include <chrono>


//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief General timer, templated on a chrono clock
//////////////////////////////////////////////////////////////////////////////////////////////
template<class clock>
class BaseTimer {
public:
  typedef std::chrono::duration<double, typename clock::period> cycle_t;
  typedef std::chrono::duration<unsigned long long, std::pico> picoseconds_t;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Default constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  BaseTimer() {
    reset();
  }

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Reset timer
  //////////////////////////////////////////////////////////////////////////////////////////////
  void reset() {
    start_ = clock::now();
  }

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get seconds since last reset
  //////////////////////////////////////////////////////////////////////////////////////////////
  double seconds() const {
    auto end = clock::now();
    auto ticks = cycle_t(end-start_);
    return double(std::chrono::duration_cast<std::chrono::nanoseconds>(cycle_t(end-start_)).count())/1E9;
  }

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get milliseconds since last reset
  //////////////////////////////////////////////////////////////////////////////////////////////
  double milliseconds() const {
    auto end = clock::now();
    return double(std::chrono::duration_cast<std::chrono::nanoseconds>(cycle_t(end-start_)).count())/1E6;
  }

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get microseconds since last reset
  //////////////////////////////////////////////////////////////////////////////////////////////
  double microseconds() const {
    auto end = clock::now();
    return double(std::chrono::duration_cast<picoseconds_t>(cycle_t(end-start_)).count())/1E6;
  }

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get nanoseconds since last reset
  //////////////////////////////////////////////////////////////////////////////////////////////
  double nanoseconds() const {
    auto end = clock::now();
    return double(std::chrono::duration_cast<picoseconds_t>(cycle_t(end-start_)).count())/1E3;
  }

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get picoseconds since last reset
  //////////////////////////////////////////////////////////////////////////////////////////////
  double picoseconds() const {
    auto end = clock::now();
    return double(std::chrono::duration_cast<picoseconds_t>(cycle_t(end-start_)).count());
  }

private:
  std::chrono::time_point<clock> start_;

};


//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Implements a chrono interface for the Intel RTDSC tick count register
//////////////////////////////////////////////////////////////////////////////////////////////
template<uint64_t HZ>
struct RtdscClock
{
  typedef unsigned long long                 rep;
  typedef std::ratio<1, HZ>                  period; // My machine is 2.8 GHz
  typedef std::chrono::duration<rep, period> duration;
  typedef std::chrono::time_point<RtdscClock>     time_point;
  static const bool is_steady =              true;

  static time_point now() noexcept
  {
    unsigned lo, hi;
    asm volatile("rdtsc" : "=a" (lo), "=d" (hi));
    return time_point(duration(static_cast<rep>(hi) << 32 | lo));
  }
};


//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Container for timers based on chrono
//////////////////////////////////////////////////////////////////////////////////////////////
struct ChronoTimer {
  typedef BaseTimer<std::chrono::high_resolution_clock> HighResolutionTimer;
  typedef BaseTimer<std::chrono::monotonic_clock> MonotonicTimer;
  typedef BaseTimer<std::chrono::system_clock> SystemTimer;
};

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Contianer for timers based on processor ticks; templated on CPU frequency [Hz]
//////////////////////////////////////////////////////////////////////////////////////////////
template<uint64_t HZ>
struct TickTimer {
  typedef BaseTimer<RtdscClock<HZ> > RtdscTimer;
};

#endif //LGMATH_PRECISIONTIMER_HPP
