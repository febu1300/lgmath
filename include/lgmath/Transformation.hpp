//////////////////////////////////////////////////////////////////////////////////////////////
/// @file Transformation.hpp
/// @brief Header file for a transformation matrix class.
/// @details Light weight transformation class, intended to be fast, and not to provide
///          unnecessary functionality.
///
/// @author Sean Anderson
//////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////
///
/// A note on EIGEN_MAKE_ALIGNED_OPERATOR_NEW (Sean Anderson, as of May 23, 2013)
/// (also see http://eigen.tuxfamily.org/dox-devel/group__TopicStructHavingEigenMembers.html)
///
/// Fortunately, Eigen::Matrix3d and Eigen::Vector3d are NOT 16-byte vectorizable,
/// therefore this class should not require alignment, and can be used normally in STL.
///
/// To inform others of the issue, classes that include *fixed-size vectorizable Eigen types*,
/// see http://eigen.tuxfamily.org/dox-devel/group__TopicFixedSizeVectorizable.html,
/// must include the above macro! Furthermore, special considerations must be taken if
/// you want to use them in STL containers, such as std::vector or std::map.
///
/// The macro overload the dynamic "new" operator so that it generates
/// 16-byte-aligned pointers, this MUST be in the public section of the header!
///
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef LGM_TRANSFORMATION_HPP
#define LGM_TRANSFORMATION_HPP

#include <Eigen/Core>

namespace lgmath {
namespace se3 {

class Transformation
{
 public:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Default constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation();

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Copy constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation(const Transformation& T);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation(const Eigen::Matrix4d& T);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Constructor. The transformation will be T_ba = [C_ba, -C_ba*r_ba_ina; 0 0 0 1]
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation(const Eigen::Matrix<double,3,3>& C_ba, const Eigen::Matrix<double,3,1>& r_ba_ina);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Constructor. The transformation will be T_ba = vec2tran(vec)
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation(const Eigen::Matrix<double,6,1>& vec, unsigned int numTerms = 0);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Constructor. The transformation will be T_ba = vec2tran(vec)
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation(const Eigen::VectorXd& vec);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Destructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  ~Transformation() {}

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Assignment operator. Note pass-by-value is intentional.
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation& operator=(Transformation T);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Gets basic matrix representation of the transformation
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double,4,4> matrix() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Gets the underlying rotation matrix
  //////////////////////////////////////////////////////////////////////////////////////////////
  const Eigen::Matrix<double,3,3>& C_ba() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Gets the "forward" translation r_ba_ina = -C_ba.transpose()*r_ab_inb
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double,3,1> r_ba_ina() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Gets the underlying r_ab_inb vector.
  //////////////////////////////////////////////////////////////////////////////////////////////
  const Eigen::Matrix<double,3,1>& r_ab_inb() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Get the corresponding Lie algebra using the logarithmic map
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double,6,1> vec() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Get the inverse matrix
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation inverse() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Get the 6x6 adjoint transformation matrix
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double,6,6> adjoint() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief In-place right-hand side multiply T_rhs
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation& operator*=(const Transformation& T_rhs);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Right-hand side multiply T_rhs
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation operator*(const Transformation& T_rhs) const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief In-place right-hand side multiply this matrix by the inverse of T_rhs
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation& operator/=(const Transformation& T_rhs);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Right-hand side multiply this matrix by the inverse of T_rhs
  //////////////////////////////////////////////////////////////////////////////////////////////
  Transformation operator/(const Transformation& T_rhs) const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// @brief Right-hand side multiply this matrix by the homogeneous vector p_a
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double,4,1> operator*(const Eigen::Matrix<double,4,1>& p_a) const;

 private:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// Rotation matrix from a to b
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double,3,3> C_ba_;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// Translation vector from b to a, expressed in frame b
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double,3,1> r_ab_inb_;

};

} // se3
} // lgmath

//////////////////////////////////////////////////////////////////////////////////////////////
/// @brief print transformation
//////////////////////////////////////////////////////////////////////////////////////////////
std::ostream& operator<<(std::ostream& out, const lgmath::se3::Transformation& T);

#endif // LGM_TRANSFORMATION_HPP
