//////////////////////////////////////////////////////////////////////////////////////////////
/// \file SE3.hpp
/// \brief Header file for the SE3 Lie Group math functions.
/// \details These namespace functions provide implementations of the special Euclidean (SE)
///          Lie group functions that we commonly use in robotics.
///
/// \author Sean Anderson
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef LGM_SE3_PUBLIC_HPP
#define LGM_SE3_PUBLIC_HPP

#include <Eigen/Core>

/////////////////////////////////////////////////////////////////////////////////////////////
/// Lie Group Math - Special Euclidean Group
/////////////////////////////////////////////////////////////////////////////////////////////
namespace lgmath {
namespace se3 {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief builds the 4x4 "skew symmetric matrix" (see eq. 4 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,4,4> hat(const Eigen::Matrix<double,3,1>& rho, const Eigen::Matrix<double,3,1>& aaxis);
Eigen::Matrix<double,4,4> hat(const Eigen::Matrix<double,6,1>& vec);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief builds the 6x6 curly hat matrix (see eq. 12 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,6,6> curlyhat(const Eigen::Matrix<double,3,1>& rho, const Eigen::Matrix<double,3,1>& aaxis);
Eigen::Matrix<double,6,6> curlyhat(const Eigen::Matrix<double,6,1>& vec);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief turns a 4x1 homogeneous point into the 4x6 matrix (see eq. 72 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,4,6> point2fs(const Eigen::Matrix<double,3,1>& p, double scale = 1);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief turns a 4x1 homogeneous point into the 6x4 matrix (see eq. 72 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,6,4> point2sf(const Eigen::Matrix<double,3,1>& p, double scale = 1);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief builds a transformation matrix using the exponential map (see Barfoot-TRO-2014 Appendix B1)
//////////////////////////////////////////////////////////////////////////////////////////////
void vec2tran_analytical(const Eigen::Matrix<double,3,1>& rho, const Eigen::Matrix<double,3,1>& aaxis,
                         Eigen::Matrix<double,3,3>* outRot, Eigen::Matrix<double,3,1>* outTrans);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief builds a transformation matrix using the first N terms of the infinite series (see eq. 96 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
void vec2tran_numerical(const Eigen::Matrix<double,3,1>& rho, const Eigen::Matrix<double,3,1>& aaxis,
                        Eigen::Matrix<double,3,3>* outRot, Eigen::Matrix<double,3,1>* outTrans,
                        unsigned int numTerms = 0);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief builds components of the transformation matrix, analytical or numeric is determined by numTerms
//////////////////////////////////////////////////////////////////////////////////////////////
void vec2tran(const Eigen::Matrix<double,6,1>& vec, Eigen::Matrix<double,3,3>* outRot,
              Eigen::Matrix<double,3,1>* outTrans, unsigned int numTerms = 0);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief builds a 4x4 transformation matrix, analytical or numeric is determined by numTerms
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,4,4> vec2tran(const Eigen::Matrix<double,6,1>& vec, unsigned int numTerms = 0);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief compute the matrix log of a transformation matrix (see Barfoot-TRO-2014 Appendix B2)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,6,1> tran2vec(const Eigen::Matrix<double,3,3>& rot, const Eigen::Matrix<double,3,1>& trans);
Eigen::Matrix<double,6,1> tran2vec(const Eigen::Matrix<double,4,4>& mat);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief builds the 6x6 adjoint transformation matrix from a 4x4 one (see eq. 101 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,6,6> tranAd(const Eigen::Matrix<double,3,3>& rot, const Eigen::Matrix<double,3,1>& trans);
Eigen::Matrix<double,6,6> tranAd(const Eigen::Matrix<double,4,4>& mat);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief construction of the 3x3 "Q" matrix, used in the 6x6 Jacobian of SE(3) (see eq. 102 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,3,3> vec2Q(const Eigen::Matrix<double,3,1>& rho, const Eigen::Matrix<double,3,1>& aaxis);
Eigen::Matrix<double,3,3> vec2Q(const Eigen::Matrix<double,6,1>& vec);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief construction of the 6x6 Jacobian of SE(3) (see eq. 100 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,6,6> vec2jac(const Eigen::Matrix<double,3,1>& rho, const Eigen::Matrix<double,3,1>& aaxis);
Eigen::Matrix<double,6,6> vec2jac(const Eigen::Matrix<double,6,1>& vec, unsigned int numTerms = 0);

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief construction of the 6x6 inverse Jacobian of SE(3) (see eq. 103 in Barfoot-TRO-2014)
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::Matrix<double,6,6> vec2jacinv(const Eigen::Matrix<double,3,1>& rho, const Eigen::Matrix<double,3,1>& aaxis);
Eigen::Matrix<double,6,6> vec2jacinv(const Eigen::Matrix<double,6,1>& vec, unsigned int numTerms = 0);

} // se3
} // lgmath

#endif // LGM_SE3_PUBLIC_HPP
